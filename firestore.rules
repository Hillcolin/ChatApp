rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions
    function isSignedIn() {
      return request.auth != null;
    }

      // Metrics: allow authenticated clients to create metrics documents so the
      // client can record telemetry (latency, sync events, errors). Reads are
      // denied by default to keep metrics private; adjust if you want in-app
      // viewing of metrics.
      match /metrics/{metricId} {
        allow create: if isSignedIn();
        allow read: if false;
        allow update, delete: if false;
      }

    function isValidText(t) {
      return t is string && t.size() > 0 && t.size() <= 2000;
    }

    function isValidChannelName(n) {
      return n is string && n.size() > 0 && n.size() <= 100;
    }

    // Channels: allow anyone to list channels (for login screen visualization),
    // but require authentication for creating/updating/deleting.
    match /channels/{channelId} {
      allow read: if true;  // Allow unauthenticated users to count channels

      allow create: if isSignedIn()
        && request.resource.data.keys().hasAll(['name'])
        && isValidChannelName(request.resource.data.name);

      // Allow update/delete only to the creator if createdBy is present, otherwise allow updates from auth users (simple behavior).
      allow update: if isSignedIn() && (
        // Creator (or when createdBy not set) may update channel metadata (name, createdBy, createdAt, lastMessageAt)
        (
          (resource.data.createdBy == request.auth.uid || !resource.data.keys().hasAny(['createdBy']))
          && request.resource.data.keys().hasOnly(['name','createdBy','createdAt','lastMessageAt'])
          && isValidChannelName(request.resource.data.name)
          && (request.resource.data.lastMessageAt is timestamp || request.resource.data.lastMessageAt == null)
        )
        // Allow any signed-in user to update only lastMessageAt (used when posting messages)
        || (
          request.resource.data.keys().hasOnly(['lastMessageAt'])
          && (request.resource.data.lastMessageAt is timestamp || request.resource.data.lastMessageAt == null)
        )
      );

      allow delete: if isSignedIn() && (resource.data.createdBy == request.auth.uid || !resource.data.keys().hasAny(['createdBy']));

      // Messages stored as subcollection under the channel
      match /messages/{messageId} {
        allow read: if isSignedIn();

        allow create: if isSignedIn()
          && request.resource.data.keys().hasAll(['text','username','uid'])
          && isValidText(request.resource.data.text)
          && (request.resource.data.username is string)
          && (request.resource.data.uid is string)
          && request.resource.data.uid == request.auth.uid
          && (request.resource.data.createdAt is timestamp || request.resource.data.createdAt == null)
          // if replyTo provided, validate its structure (be permissive about top-level keys)
          && (
            !('replyTo' in request.resource.data)
            || (
              (request.resource.data.replyTo is map)
              && (request.resource.data.replyTo.id is string)
              && (request.resource.data.replyTo.username is string)
              && (request.resource.data.replyTo.text is string)
              && isValidText(request.resource.data.replyTo.text)
            )
          );

        // Allow the original author to edit their message. Editing may include
        // setting an `editedAt` timestamp so clients can show an "edited" marker.
        // We must allow the existing immutable fields (uid, username, createdAt)
        // to remain present in the resulting document; update requests typically
        // include those unchanged fields. Therefore we validate that those fields
        // are not changed and that only `text` (and optionally `editedAt`) are
        // modified.
        allow update: if isSignedIn()
          && resource.data.uid == request.auth.uid
          // ensure immutable fields are unchanged
          && request.resource.data.uid == resource.data.uid
          && request.resource.data.username == resource.data.username
          && request.resource.data.createdAt == resource.data.createdAt
          // text must be valid
          && isValidText(request.resource.data.text)
          // if provided, editedAt must be a timestamp (client may omit it and rely on serverTimestamp)
          && (request.resource.data.editedAt is timestamp || request.resource.data.editedAt == null);

        allow delete: if isSignedIn() && resource.data.uid == request.auth.uid;
      }
    }

    // Deny everything else by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
