rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions
    function isSignedIn() {
      return request.auth != null;
    }

      // Metrics: allow authenticated clients to create metrics documents so the
      // client can record telemetry (latency, sync events, errors). Reads are
      // denied by default to keep metrics private; adjust if you want in-app
      // viewing of metrics.
      match /metrics/{metricId} {
        allow create: if isSignedIn();
        allow read: if false;
        allow update, delete: if false;
      }

    function isValidText(t) {
      return t is string && t.size() > 0 && t.size() <= 2000;
    }

    function isValidChannelName(n) {
      return n is string && n.size() > 0 && n.size() <= 100;
    }

    // Channels: enforce membership lists and restrict message access to members.
    match /channels/{channelId} {
      // channel metadata can be read by signed-in users (UI may list channels),
      // but actual message access below is enforced against `members`.
      allow read: if isSignedIn();

      // Creating a channel must include an initial `members` array (emails)
      // and the creating user's email must be present. Creator must set
      // `createdBy` to their uid.
      allow create: if isSignedIn()
        && request.resource.data.keys().hasAll(['name','members','createdBy'])
        && isValidChannelName(request.resource.data.name)
        && request.resource.data.createdBy == request.auth.uid
        && (request.resource.data.members is list)
        && request.resource.data.members.size() > 0
        && request.resource.data.members.size() <= 200
        // creator must include themselves (by email or uid) in members
        && (
          (request.auth.token.email in request.resource.data.members)
          || (request.auth.uid in request.resource.data.members)
        );

      // Allow updates to channel metadata by the creator only, and allow
      // existing members to update only the `members` array (invite others).
      allow update: if isSignedIn() && (
        // Creator may update metadata and members
        (
          resource.data.createdBy == request.auth.uid
          && request.resource.data.keys().hasOnly(['name','createdBy','createdAt','lastMessageAt','members'])
          && isValidChannelName(request.resource.data.name)
          && (request.resource.data.lastMessageAt is timestamp || request.resource.data.lastMessageAt == null)
          // if members provided, validate basic list shape and size
          && (!('members' in request.resource.data) || ((request.resource.data.members is list) && request.resource.data.members.size() <= 200))
        )
        // Existing members may only update the members list
        || (
          request.resource.data.keys().hasOnly(['members'])
          && (request.resource.data.members is list)
          && request.resource.data.members.size() <= 200
          // requester must already be listed as a member (by email or uid)
          && (
            (request.auth.token.email in resource.data.members)
            || (request.auth.uid in resource.data.members)
          )
        )
      );

      // Deletion allowed only to creator
      allow delete: if isSignedIn() && resource.data.createdBy == request.auth.uid;

      // Messages stored as subcollection under the channel. Only channel
      // members (by email) are allowed to read or create messages.
      match /messages/{messageId} {
        // read allowed if caller is listed as a member (by email or uid)
        allow read: if isSignedIn()
          && exists(/databases/$(database)/documents/channels/$(channelId))
          && (get(/databases/$(database)/documents/channels/$(channelId)).data.members is list)
          && (
            (request.auth.token.email in get(/databases/$(database)/documents/channels/$(channelId)).data.members)
            || (request.auth.uid in get(/databases/$(database)/documents/channels/$(channelId)).data.members)
          );

        // create allowed only for members and when uid matches auth
        allow create: if isSignedIn()
          && exists(/databases/$(database)/documents/channels/$(channelId))
          && (get(/databases/$(database)/documents/channels/$(channelId)).data.members is list)
          && (
            (request.auth.token.email in get(/databases/$(database)/documents/channels/$(channelId)).data.members)
            || (request.auth.uid in get(/databases/$(database)/documents/channels/$(channelId)).data.members)
          )
          && request.resource.data.keys().hasAll(['text','username','uid'])
          && isValidText(request.resource.data.text)
          && (request.resource.data.username is string)
          && (request.resource.data.uid is string)
          && request.resource.data.uid == request.auth.uid
          && (request.resource.data.createdAt is timestamp || request.resource.data.createdAt == null)
          // if replyTo provided, validate its structure
          && (
            !('replyTo' in request.resource.data)
            || (
              (request.resource.data.replyTo is map)
              && (request.resource.data.replyTo.id is string)
              && (request.resource.data.replyTo.username is string)
              && (request.resource.data.replyTo.text is string)
              && isValidText(request.resource.data.replyTo.text)
            )
          );

        // updates allowed only to original author and only valid edits
        allow update: if isSignedIn()
          && resource.data.uid == request.auth.uid
          // ensure immutable fields are unchanged
          && request.resource.data.uid == resource.data.uid
          && request.resource.data.username == resource.data.username
          && request.resource.data.createdAt == resource.data.createdAt
          // text must be valid
          && isValidText(request.resource.data.text)
          // if provided, editedAt must be a timestamp
          && (request.resource.data.editedAt is timestamp || request.resource.data.editedAt == null)
          // and the editor must be a member of the parent channel
          && (get(/databases/$(database)/documents/channels/$(channelId)).data.members is list)
          && (
            (request.auth.token.email in get(/databases/$(database)/documents/channels/$(channelId)).data.members)
            || (request.auth.uid in get(/databases/$(database)/documents/channels/$(channelId)).data.members)
          );

        // delete allowed only to author (and they must be a member)
        allow delete: if isSignedIn()
          && resource.data.uid == request.auth.uid
          && (get(/databases/$(database)/documents/channels/$(channelId)).data.members is list)
          && (
            (request.auth.token.email in get(/databases/$(database)/documents/channels/$(channelId)).data.members)
            || (request.auth.uid in get(/databases/$(database)/documents/channels/$(channelId)).data.members)
          );
      }
    }

    // Deny everything else by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
